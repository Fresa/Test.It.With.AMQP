<#@ template language="C#" visibility="internal" debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ assembly name="$(SolutionDir)\Testing.RabbitMQ\bin\Debug\Test.It.With.RabbitMQ.dll" #>
<#@ import namespace="Test.It.With.RabbitMQ.Protocol" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="Test.It.With.RabbitMQ.Extensions" #>
<#@ import namespace="Test.It.With.RabbitMQ.Protocol.Definitions" #>
<#
    var path = Path.Combine(Host.ResolvePath(@"amqp0-9-1\amqp0-9-1.xml"));
    var definition = new XmlDocument();
    definition.Load(path);
    var protocol = new Protocol(definition);
    var typeConverter = new ProtocolDomainTypeConverter();

	void Tab(Action action) { this.Tab(action); }
    void Block(Action action) { this.Block(action); }
	void PrintOnNewRowForEach<TValue>(IEnumerable<TValue> iterator, Action<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void PrintOnNewRowForEachWithIndex<TValue>(IEnumerable<TValue> iterator, ActionDelegateWithIndexAndLength<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void WriteNewLine(int count = 1) { this.WriteNewLine(count); }

    void GenerateAssertion(Assert assert, string parameterName)
    {
        switch (assert.Check.ToLower())
        {
            case "notnull":
                #>Requires.NotNullAllowStructs(<#= parameterName #>, nameof(<#= parameterName #>));<#
                return;
			case "length":
                #>Requires.Range(<#= parameterName #>.Length <= <#= assert.Value #>, nameof(<#= parameterName #>));<#
                return;
			case "regexp":
                #>Requires.That(Regex.IsMatch(<#= parameterName #>, "<#= assert.Value #>"), nameof(<#= parameterName #>), "Value must meet the following regex criteria: <#= assert.Value #>");<#
                return;
            case "le":
                // todo: How should we implement this?
                return;
        }

        throw new NotSupportedException($"Unknown assertion: '{assert.Check}'.");
    }

	void GenerateDocumentation(string documentation)
    {
        if (string.IsNullOrEmpty(documentation))
        {
            return;
        }

        #>/// <summary><#
        WriteNewLine();
        foreach (var documentationRow in documentation.Trim().Split('\n'))
        {
            #>/// <#= documentationRow.Trim() #><#
            WriteNewLine();
        }
		#>/// </summary><#
        WriteNewLine();
    }
#>
// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.

using System;
using Validation;
using System.Text.RegularExpressions;
using Test.It.With.RabbitMQ.MessageClient;
using Test.It.With.RabbitMQ.Protocol;
using System.Collections.Generic;

namespace Test.It.With.RabbitMQ<#
Block(() =>
{
	// Protocol
	#>internal class AmqProtocol : IProtocol<#
	Block(() =>
	{
	    #>public IVersion Version { get; } = new ProtocolVersion(); <#
	    WriteNewLine(2);
	    #>public IMethod GetMethod(AmqpReader reader)<#
	    Block(() =>
	    {
			#>var classId = reader.ReadShortUnsignedInteger();<#
			WriteNewLine();
			#>var methodId = reader.ReadShortUnsignedInteger();<#
	        WriteNewLine(2);
			#>var method = _methodFactory[classId][methodId]();<#
			WriteNewLine();
			#>method.ReadFrom(reader);<#
			WriteNewLine();
			#>return method;<#
	    });

	    WriteNewLine(2);

	    #>private readonly Dictionary<int, Dictionary<int, Func<IMethod>>> _methodFactory = new Dictionary<int, Dictionary<int, Func<IMethod>>><#
	    Block(() =>
	    {
			PrintOnNewRowForEachWithIndex(protocol.Classes.Values, (@class, index, length) =>
			{
				#>{ <#= @class.Index #>, new Dictionary<int, Func<IMethod>> { <#
				WriteNewLine();
			    Tab(() =>
			    {
			        PrintOnNewRowForEachWithIndex(@class.Methods.Values, (method, methodIndex, methodCount) =>
			        {
						#>{ <#= method.Index #>, () => new <#= @class.Name.ToPascalCase('-') #>.<#= method.Name.ToPascalCase('-') #>() }<#

						if (methodIndex + 1 != methodCount)
						{
							#>,<#
						}
			        });
			    });
				#>}}<#

			    if (index + 1 != length)
			    {
			        #>,<#
			    }
			});
	    });
		#>;<#
		WriteNewLine(2);

		#>private class ProtocolVersion : IVersion<#
	    Block(() =>
	    {
	        #>public int Major { get; } = <#= protocol.Major #>;<#
	        WriteNewLine();
	        #>public int Minor { get; } = <#= protocol.Minor #>;<#
	        WriteNewLine();
	        #>public int Revision { get; } = <#= protocol.Revision #>;<#
	    });
	});

    WriteNewLine(2);

	// Constants
    #>internal class Constants<#
	Block(() =>
    {
        PrintOnNewRowForEachWithIndex(protocol.Constants.Values, (constant, index, count) =>
        {
            GenerateDocumentation(constant.Documentation);
            #>private const int <#= constant.Name.ToPascalCase('-') #> = <#= constant.Value #>;<#
            if (index + 1 != count) WriteNewLine();
        });
    });
    
    WriteNewLine(2);

    // Domain types
    PrintOnNewRowForEach(protocol.Domains.Values, domain =>
    {
        var className = domain.Name.ToPascalCase('-');
        var type = typeConverter.Convert(domain.Type).GetPrettyFullName();

        GenerateDocumentation(domain.Documentation);
        #>public struct <#= className #> <# 
		Block(() =>
        {
            #>public <#= type #> Value { get; }<#
            WriteNewLine(2);
            #>internal <#= className #>(<#= type #> value)<#
			Block(() =>
            {
                PrintOnNewRowForEach(domain.Asserts, assert => { GenerateAssertion(assert, "value"); });
                #>Value = value;<#
            });
        });
        WriteNewLine();
    });
    
    // Methods
    PrintOnNewRowForEach(protocol.Classes.Values, @class =>
    {
        var className = @class.Name.ToPascalCase('-');

		WriteNewLine();
		GenerateDocumentation(@class.Documentation);
		#>public class <#= className #><#
		Block(() => 
		{
			PrintOnNewRowForEachWithIndex(@class.Methods.Values, (method, index, length) =>
			{
				var methodName = method.Name.ToPascalCase('-');

				GenerateDocumentation(method.Documentation);
				#>public class <#= methodName #> : IMethod<#
				Block(() =>
				{
					#>public int ClassId { get; } = <#= @class.Index #>;<#
					WriteNewLine();
					#>public int MethodId { get; } = <#= @method.Index #>;<#
					WriteNewLine();

					PrintOnNewRowForEach(method.Fields.Values, field =>
					{
						GenerateDocumentation(field.Documentation);

						#>private <#= field.Domain.Name.ToPascalCase('-') #> _<#= field.Name.ToCamelCase('-') #>;<#
						WriteNewLine();
						#>public <#= field.Domain.Name.ToPascalCase('-') #> <#= field.Name.ToPascalCase('-') #>_<# 
						Block(() =>
						{
							#>get<#
							Block(() =>
							{
								#>return _<#= field.Name.ToCamelCase('-') #>;<#
							});
							WriteNewLine();
							#>set<#
							Block(() =>
							{
								if (field.Asserts.Any())
								{
									PrintOnNewRowForEach(field.Asserts, fieldAssert =>
									{
										GenerateAssertion(fieldAssert, "value.Value");
									});
									WriteNewLine();
								}
								#>_<#= field.Name.ToCamelCase('-') #> = value;<#
							});
						});
						WriteNewLine();
					});

					WriteNewLine();
					#>public void ReadFrom(AmqpReader reader)<#
					Block(() =>
					{
						PrintOnNewRowForEach(method.Fields.Values, field =>
						{
							#>_<#= field.Name.ToCamelCase('-') #> = new <#= field.Domain.Name.ToPascalCase('-') #>(reader.<#= typeConverter.GetReaderMethod(field.Domain.Type) #>());<#
						});
					});

					WriteNewLine(2);
					#>public void WriteTo(AmqpWriter writer)<#
					Block(() =>
					{
						PrintOnNewRowForEach(method.Fields.Values, field =>
						{
							#>writer.<#= typeConverter.GetWriterMethod(field.Domain.Type) #>(_<#= field.Name.ToCamelCase('-') #>.Value);<#
						});
					});
				});

			    if (index + 1 != length)
			    {
			        WriteNewLine();			        
			    }
			});
		});
    });
});
#>