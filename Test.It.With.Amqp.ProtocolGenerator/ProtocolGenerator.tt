<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ assembly name="$(SolutionDir)\Test.It.With.Amqp.Protocol\bin\Debug\Test.It.With.Amqp.Protocol.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="Test.It.With.Amqp.Protocol" #>
<#@ import namespace="Test.It.With.Amqp.Protocol.Definitions" #>
<#@ import namespace="Test.It.With.Amqp.Protocol.Extensions" #>
<#
    var path = Path.Combine(Host.ResolvePath(@"amqp0-9-1\amqp0-9-1.xml"));
    var definition = new XmlDocument();
    definition.Load(path);
    var protocol = new Protocol(definition);
    var typeConverter = new ProtocolDomainTypeConverter();

	void Tab(Action action) { this.Tab(action); }
    void Block(Action action) { this.Block(action); }
	void PrintOnNewRowForEach<TValue>(IEnumerable<TValue> iterator, Action<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void PrintOnNewRowForEachWithIndex<TValue>(IEnumerable<TValue> iterator, ActionDelegateWithIndexAndLength<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void _(int count = 1) { this.WriteNewLine(count); }
    
    void GenerateAssertion(Assert assert, string parameterName)
    {
        switch (assert.Check.ToLower())
        {
            case "notnull":
                #>Requires.NotNullAllowStructs(<#= parameterName #>, nameof(<#= parameterName #>));<#
                return;
			case "length":
                #>Requires.Range(<#= parameterName #>.Length <= <#= assert.Value #>, nameof(<#= parameterName #>));<#
                return;
			case "regexp":
                #>Requires.That(Regex.IsMatch(<#= parameterName #>, "<#= assert.Value #>"), nameof(<#= parameterName #>), "Value must meet the following regex criteria: <#= assert.Value #>");<#
                return;
            case "le":
                // todo: How should we implement this?
                return;
        }

        throw new NotSupportedException($"Unknown assertion: '{assert.Check}'.");
    }

	void GenerateDocumentation(string documentation, string grammarDocumentation = null)
    {
        if (string.IsNullOrEmpty(documentation))
        {
            return;
        }

        #>/// <summary><# _();
        foreach (var documentationRow in documentation.Trim().Split('\n'))
        {
            #>/// <#= documentationRow.Trim() #><# _();
        }
		#>/// </summary><# _();
        if (grammarDocumentation != null)
        {
            #>/// <example><# _();
			foreach (var documentationRow in grammarDocumentation.TrimEnd().Split('\n'))
			{
				#>/// <#= documentationRow.TrimEnd() #><# _();
			}
			#>/// </example><# _();
        }
    }
#>
// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.

using System;
using System.Net;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Validation;
using Test.It.With.Amqp.Protocol;
using Test.It.With.Amqp.Protocol.Extensions;

namespace Test.It.With.Amqp<# Block(() =>
{
	// Protocol
	#>internal class AmqProtocol : IProtocol<# Block(() =>
	{
	    #>public IVersion Version { get; } = new ProtocolVersion(); <# _(2);

	    #>public IMethod GetMethod(AmqpReader reader)<# Block(() =>
	    {
			#>var classId = reader.ReadShortUnsignedInteger();<# _(2);
			
			#>if (_methodFactory.TryGetValue(classId, out Dictionary<int, Func<IMethod>> methodRegister) == false)<# Block(() =>
			{
			    #>throw new InvalidOperationException($"There is no class with id {classId} defined.");<#
			}); _(2);
			
			#>var methodId = reader.ReadShortUnsignedInteger();<# _(2);

			#>if (methodRegister.TryGetValue(methodId, out Func<IMethod> factory) == false)<# Block(() =>
			{
			    #>throw new InvalidOperationException($"There is no method defined with id {methodId} in class with id {classId}.");<#
			}); _(2);
			
			#>var method = factory();<# _();			
			#>method.ReadFrom(reader);<# _();
			#>return method;<#
	    }); _(2);

		#>public IContentHeader GetContentHeader(AmqpReader reader)<# Block(() =>
	    {
			#>var classId = reader.ReadShortUnsignedInteger();<# _(2);
			
			#>if (_contentHeaderFactory.TryGetValue(classId, out Func<IContentHeader> factory) == false)<# Block(() =>
			{
			    #>throw new InvalidOperationException($"There is no content header defined for class with id {classId}.");<#
			}); _(2);
			
			#>var contentHeader = factory();<# _();			
			#>contentHeader.ReadFrom(reader);<# _();
			#>return contentHeader;<#
	    }); _(2);


	    #>private readonly Dictionary<int, Dictionary<int, Func<IMethod>>> _methodFactory = new Dictionary<int, Dictionary<int, Func<IMethod>>><# Block(() =>
	    {
			PrintOnNewRowForEachWithIndex(protocol.Classes.Values, (@class, index, length) =>
			{
				#>{ <#= @class.Index #>, new Dictionary<int, Func<IMethod>> { <#
				_();
			    Tab(() =>
			    {
			        PrintOnNewRowForEachWithIndex(@class.Methods.Values, (method, methodIndex, methodCount) =>
			        {
						#>{ <#= method.Index #>, () => new <#= @class.Name.ToPascalCase('-') #>.<#= method.Name.ToPascalCase('-') #>() }<#

						if (methodIndex + 1 != methodCount) {#>,<#}
			        });
			    });
				#>}}<#

			    if (index + 1 != length) {#>,<#}
			});
	    });
		#>;<# _(2);

		#>private readonly Dictionary<int, Func<IContentHeader>> _contentHeaderFactory = new Dictionary<int, Func<IContentHeader>><# Block(() =>
	    {
	        var classesWithContentHeader = protocol.Classes.Values.Where(@class => @class.Fields.Any());
			PrintOnNewRowForEachWithIndex(classesWithContentHeader, (@class, index, length) =>
			{
				#>{ <#= @class.Index #>, () => new <#= @class.Name.ToPascalCase('-') #>.ContentHeader() }<#
			    
			    if (index + 1 != length) {#>,<#}
			});
	    });
		#>;<# _(2);

		#>private class ProtocolVersion : IVersion<# Block(() =>
	    {
	        #>public int Major { get; } = <#= protocol.Major #>;<# _();
	        #>public int Minor { get; } = <#= protocol.Minor #>;<# _();
	        #>public int Revision { get; } = <#= protocol.Revision #>;<#
	    });
	}); _(2);
	
	// Constants
    #>internal class Constants<# Block(() =>
    {
        PrintOnNewRowForEachWithIndex(protocol.Constants.Values, (constant, index, count) =>
        {
            GenerateDocumentation(constant.Documentation);
            #>internal const int <#= constant.Name.ToPascalCase('-') #> = <#= constant.Value #>;<# if (index + 1 != count) _();
        });
    }); _(2);

    // Domain types
    PrintOnNewRowForEach(protocol.Domains.Values, domain =>
    {
        var className = domain.Name.ToPascalCase('-');
        var type = typeConverter.Convert(domain.Type).GetPrettyFullName();

        GenerateDocumentation(domain.Documentation);
        #>public struct <#= className #> <# Block(() =>
        {
            #>public <#= type #> Value { get; }<# _(2);

            #>internal <#= className #>(<#= type #> value)<# Block(() =>
            {
                PrintOnNewRowForEach(domain.Asserts, assert => { GenerateAssertion(assert, "value"); }); if (domain.Asserts.Any()) _();
                #>Value = value;<#
            });
        }); _();
    });
    
    // Classes
    PrintOnNewRowForEach(protocol.Classes.Values, @class =>
    {
        var className = @class.Name.ToPascalCase('-'); _();
		GenerateDocumentation(@class.Documentation, @class.GrammarDocumentation);
		#>public class <#= className #><# Block(() => 
		{
			// Content Header
		    if (@class.Fields.Any())
		    {
		        var contentHeaderName = "ContentHeader";
		        #>public class <#= contentHeaderName #> : IContentHeader<# Block(() =>
				{
					#>public int ClassId { get; } = <#= @class.Index #>;<# _(2);

					PrintOnNewRowForEach(@class.Fields.Values, field =>
					{
						GenerateDocumentation(field.Documentation);
						#>public bool Has<#= field.Name.ToPascalCase('-') #> { get; private set; }<# _();

						#>private <#= field.Domain.Name.ToPascalCase('-') #> _<#= field.Name.ToCamelCase('-') #>;<# _();
						#>public <#= field.Domain.Name.ToPascalCase('-') #> <#= field.Name.ToPascalCase('-') #><# Block(() =>
						{
							#>get => _<#= field.Name.ToCamelCase('-') #>;<# _();
							#>set<# Block(() =>
							{
								if (field.Asserts.Any())
								{
									PrintOnNewRowForEach(field.Asserts, fieldAssert =>
									{
										GenerateAssertion(fieldAssert, "value.Value");
									}); _();
								}
								#>_<#= field.Name.ToCamelCase('-') #> = value;<#
							});
						}); _();
					});
					if (@class.Fields.Values.Any()) {_();}

					#>public void ReadFrom(AmqpReader reader)<# Block(() =>
					{
						#>var propertyFlags = reader.ReadPropertyFlags(); <# _();
						#>if (propertyFlags.Length < <#= @class.Fields.Values.Count() #>)<# Block(() =>
					    {
					        #>throw new ProtocolViolationException("There are more fields than property flags.");<# 
					    }); _(2);

					    PrintOnNewRowForEachWithIndex(@class.Fields.Values, (field, index, length) =>
						{
							#>Has<#= field.Name.ToPascalCase('-') #> = propertyFlags[<#= index #>];<# _();
							#>if (Has<#= field.Name.ToPascalCase('-') #>)<# Block(() =>
						    {
								#>_<#= field.Name.ToCamelCase('-') #> = new <#= field.Domain.Name.ToPascalCase('-') #>(reader.<#= typeConverter.GetReaderMethod(field.Domain.Type) #>());<#						        
						    });
						    if (index + 1 != length) _();
						});
					}); _(2);

					#>public void WriteTo(AmqpWriter writer)<#
					Block(() =>
					{
						#>var propertyFlags = new [] <# Block(() =>
					    {
							PrintOnNewRowForEachWithIndex(@class.Fields.Values, (field, index, length) =>
							{
								#>Has<#= field.Name.ToPascalCase('-') #><# if (index + 1 != length) { #>,<# }
							});
					    });
						#>;<# _(2);

						#>writer.WritePropertyFlags(propertyFlags);<# _(2);

					    PrintOnNewRowForEachWithIndex(@class.Fields.Values, (field, index, length) =>
						{
							#>if (Has<#= field.Name.ToPascalCase('-') #>)<# Block(() =>
						    {
								#>writer.<#= typeConverter.GetWriterMethod(field.Domain.Type) #>(_<#= field.Name.ToCamelCase('-') #>.Value);<#						        
						    }); if (index + 1 != length) _();
						});
					}); 
				}); _(2);
			}

			// Methods
			PrintOnNewRowForEachWithIndex(@class.Methods.Values, (method, index, length) =>
			{
				var methodName = method.Name.ToPascalCase('-');

				GenerateDocumentation(method.Documentation);
				#>public class <#= methodName #> : IMethod<# Block(() =>
				{
					#>public int ProtocolClassId => <#= @class.Index #>;<# _();
					#>public int ProtocolMethodId => <#= @method.Index #>;<# _(2);

					PrintOnNewRowForEach(method.Fields.Values, field =>
					{
						#>private <#= field.Domain.Name.ToPascalCase('-') #> _<#= field.Name.ToCamelCase('-') #>;<# _();
						GenerateDocumentation(field.Documentation);
						#>public <#= field.Domain.Name.ToPascalCase('-') #> <#= field.Name.ToPascalCase('-') #><# Block(() =>
						{
							#>get => _<#= field.Name.ToCamelCase('-') #>;<# _();
							#>set<# Block(() =>
							{
								if (field.Asserts.Any())
								{
									PrintOnNewRowForEach(field.Asserts, fieldAssert =>
									{
										GenerateAssertion(fieldAssert, "value.Value");
									}); _();
								}
								#>_<#= field.Name.ToCamelCase('-') #> = value;<#
							});
						}); _();
					});
					if (method.Fields.Values.Any()) {_();}

					#>public void ReadFrom(AmqpReader reader)<# Block(() =>
					{
						PrintOnNewRowForEach(method.Fields.Values, field =>
						{
							#>_<#= field.Name.ToCamelCase('-') #> = new <#= field.Domain.Name.ToPascalCase('-') #>(reader.<#= typeConverter.GetReaderMethod(field.Domain.Type) #>());<#
						});
					}); _(2);

					#>public void WriteTo(AmqpWriter writer)<#
					Block(() =>
					{
						PrintOnNewRowForEach(method.Fields.Values, field =>
						{
							#>writer.<#= typeConverter.GetWriterMethod(field.Domain.Type) #>(_<#= field.Name.ToCamelCase('-') #>.Value);<#
						});
					}); 
				});

			    if (index + 1 != length) _();
			});
		});
    });
});
#>